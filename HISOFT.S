;*******************************************
;*                                         *
;*  HISOFT.S                               *
;*   12/3/83                                *
;*                                         *
;*******************************************
;
;
;
;
;	GLOBAL		CREATE,MRDCH,MWRCH,WTHDR
;	GLOBAL		FREE?,CPSTR,DECSEC,LIST?
;	GLOBAL		READN,NERROR,DELIX,RDNXT
;	GLOBAL		MARK,WRREC,SPACE?
;	GLOBAL		ECD,ECH,WRFREE,CLOSEN
;	GLOBAL		WRC,CLOSIX,MRDIX,MWRIX
;	GLOBAL		READNC
;	GLOBAL		DONE?
;
;	EXTERNAL	DRVSEL,RDHBLK,RDBLK,WRHBLK,WRBLK	;DRIVE
;	EXTERNAL	DIS10,HEX,OP,OPHEX
;	EXTERNAL	RELNAM					;UHSOFT
;	EXTERNAL	DELBC					;DUMMY
;	EXTERNAL	CHANGE
;
;
;
; CREATE CREATES A MICRODRIVE CHANNEL FOR THE FILE SPECIFIED
; IN THE SYSTEM VARIABLES
; IF A CHANNEL FOR THE FILE HAS ALREADY BEEN OPENED FOR
; WRITING AN ERROR OCCURS
;
; THE PROCEDURE RETURNS THE NUMBER OF THE CREATED CHANNEL
; THIS NUMBER GIVES THE OFFSET+1 OF THE START OF THE CHANNEL
; DATA FROM (CHANS) AND IS APPROPRIATE FOR THE STREAM DATA
; IX POINTS TO THE CHANNEL ON RETURN
;
; CREATE CORRECTS THE ADDRESSES IN N_STR1  AND N_STR2
;
CREATE
	EXX
	LD	HL,0				; HL' WILL POINT TO MAP FOR THE CHANNEL
	EXX
	LD	IX,(CHANS)			; LOOK AT FIRST NON PERMANENT CHANNEL
	LD	DE,20
	ADD	IX,DE
CR4
						; HERE WE ARE LOOKING FOR AN EXISTING
						; CHANNEL WITH THE SAME NAME AND DRIVE
						; AND OPENED FOR WRITE.
	LD	A,(IX+0)			; DOES THE NEXT CHANNEL EXIST?
	CP	80H
	JR	Z,CR6				; NO...CREATE NEW CHANNEL
;
	LD	A,(IX+CHTYPE)			; YES..IS IT A MICRODRIVE FILE
	AND	7FH
	CP	'M'
	JR	NZ,CR5				; NO..NEXT CHANNEL
;
	LD	A,(DR+D_STR1)
	CP	(IX+CHDRIV)			; YES..SAME DRIVE?
	JR	NZ,CR5
;
CR7
	EXX					; YES..USE THE SAME MAP LATER!
	LD	L,(IX+CHMAP)
	LD	H,(IX+CHMAP+1)    
	EXX
;
	LD	BC,(DR+N_STR1)
	LD	HL,(DR+N_STR1+2)
	CALL	CPSTR				; DOES IT HAVE THE SAME NAME
	JR	NZ,CR5				; NO..NEXT CHANNEL
;
	BIT	WRFLG,(IX+CHFLAG)		; IS IT OPEN FOR WRITE?
	JR	Z,CR5				; NEXT CHANNEL IF READ.
;
	RST	SH_ERR				; FILE ALREADY OPEN FOR WRITE
	DEFB	0DH				; READ FROM A WRITE FILE
CR5						; HERE TO FIND THE NEXT CHANNEL
						; TO LOOK AT.
	LD	E,(IX+CHLEN)
	LD	D,(IX+CHLEN+1)         
	ADD	IX,DE
	JR	CR4
;
CR6						; HERE TO CREATE A NEW MICRODRIVE CHANNEL
	LD	HL,(PROG)
	DEC	HL
	PUSH	HL
	LD	BC,CHANLN
	OLDCAL	INSERT				; CREATE SPACE FOR CHANNEL DATA AND BUFFER
	POP	DE				; DE NOW POINTS TO THE NEW CHANNEL
;
	PUSH	DE				; INITIALIZE THE CHANNEL DATA AND NAME
	LD	HL,MCHDAT
	LD	BC,CHDRIV
	LDIR
;
	LD	A,(DR+D_STR1)
	LD	(IX+CHDRIV),A			; COPY DRIVE NUMBER
;
	LD	BC,CHANLN			; CORRECT THE POSITIONS OF THE NAMES
	PUSH	IX
	POP	HL
	CALL	RELNAM
;
	EX	DE,HL				; *
	LD	BC,(DR+N_STR1)			; COPY NAME INTO DATA
	BIT	7,B				; TEST FOR A FULL NAME
	JR	NZ,CR12_5
CR12
	LD	A,B
	OR	C
	JR	Z,CR12_5
	LD	A,(HL)
	LD	(IX+CHNAME),A
	INC	HL
	INC	IX
	DEC	BC
	JR	CR12
CR12_5
	POP	IX
	EXX
	LD	A,H				; NOW CHECK IF MAP ALREADY EXISTS
	OR	L
	JR	NZ,CR17
;
	LD	HL,(CHANS)			; NO..CREATE SPACE
	PUSH	HL
	DEC	HL
	LD	BC,MAPLN
	OLDCAL	INSERT
	POP	HL
;
	LD	BC,MAPLN
	ADD	IX,BC
;
	CALL	RELNAM				; CORRECT THE NAMES AGAIN
	LD	A,0FFH				; MARK MAP FULL
	LD	B,MAPLN
	PUSH    HL
CR11
	LD	(HL),A
	INC	HL
	DJNZ	CR11
	POP	HL
;
CR17
	LD	(IX+CHMAP),L			; PUT ADDRESS IN CHANNEL DATA
	LD	(IX+CHMAP+1),H
;
	PUSH	IX				; SETUP PREAMBLE FOR HEADER
	POP	HL
	LD	DE,CHHDR
	ADD	HL,DE
	EX	DE,HL				; *
	LD	HL,P_AMBL
	LD	BC,PLEN
	LDIR
;
	PUSH	IX				; SETUP PREAMBLE FOR DESCRIPTOR
	POP	HL
	LD	DE,CHDES
	LD	BC,PLEN
	ADD	HL,DE
	EX	DE,HL				; *
	LD	HL,P_AMBL
	LDIR
;
	PUSH	IX				; WORK OUT CHANNEL NUMBER
	POP	HL
	LD	DE,(CHANS)
	OR	A
	SBC	HL,DE
	INC	HL
	RET					; AND RETURN WITH IT IN HL
;
;
; DELIX DOES THE OPPOSITE OF CREATE
; THE CHANNEL NUMBER IS SPECIFIED BY HL
;
DELIX
	LD	L,(IX+CHMAP)			; YES..GET MAP ADDRESS
	LD	H,(IX+CHMAP+1)
	PUSH	HL
	LD	A,(IX+CHDRIV)			; AND DRIVE NUMBER
	PUSH    AF
;
	PUSH	IX				; DELETE CHANNEL
	POP	HL
	LD	BC,CHANLN
	OLDCAL	DELREC
;
	PUSH	IX
	POP	HL
	LD	DE,(CHANS)			; CHANNEL OFFSET REQUIRED IN HL
	OR	A
	SBC	HL,DE
	INC	HL
	LD	BC,CHANLN
	CALL	ADJSTR				; ADJUST THE POINTERS IN STREAMS
;
	POP	AF
	POP	HL
	LD	B,A				; NOW TAKE CARE OF THE MAP
	LD	IX,(CHANS)
	LD	DE,20
	ADD	IX,DE				; START OF IMPERMANENT CHANNELS
DEL2
	LD	A,(IX+0)			; IS THERE A CHANNEL
	CP	80H
	JR	Z,DEL5				; NO..DELETE MAP
;
	LD	A,(IX+CHTYPE)			; YES..IS IT A MICRODRIVE CHANNEL
	AND	7FH
	CP	'M'
	JR	NZ,DEL4				; NO..NEXT CHANNEL
;
	LD	A,(IX+CHDRIV)			; YES..SAME DRIVE
	CP	B
	RET	Z				; YES..KEEP MAP!
;
DEL4
	LD	E,(IX+CHLEN)			; NEXT CHANNEL
	LD	D,(IX+CHLEN+1)
	ADD	IX,DE
	JR	DEL2
;
DEL5
	LD	BC,MAPLN			; HERE IF MAP NOT USED ELSEWHERE
	PUSH	HL
	PUSH	BC
	OLDCAL	DELREC				; DELETE IT!
	POP	BC
	POP	HL
	CALL	ADJMAP				; ADJUST POINTERS TO MAPS IN OTHER CHANNELS
	RET
;
;*********************************************    
;*    MRDCH                                  *
;*********************************************
;
; THIS CODE IS CALLED AT INPUT OR INKEY TO OBTAIN A SINGLE
; CHARACTER BUT BECAUSE OF THE WAY THE CALLING PROCEDURE
; TREATS CONTROL CHARACTERS WE DO THE LINE BUFFERING HERE
; AND RETURN TO A MORE APPROPRIATE PLACE IN THE INPUT CODE
;
MRDCH
	LD	IX,(CURCHL)
	LD	HL,MRDIX
	JP	CHANGE
;
;
; THIS PROCEDURE READS A BYTE FROM THE MICRODRIVE CHANNEL
; SPECIFIED BY IX
; THE BYTE IS RETURNED IN A
; THE CARRY FLAG IS SET IF THE DATA IS OK
; NZ & NC IF END OF FILE
;
MRDIX
	BIT	WRFLG,(IX+CHFLAG)		;IS IT OPEN FOR READ
	JR	Z,MRD1
;
	RST	SH_ERR				; NO...READING FROM WRITE FILE
	DEFB	0DH
;
MRD1
	LD	E,(IX+CHBYTE)			; GET POINTER TO NEXT BYTE
	LD	D,(IX+CHBYTE+1)			; IN RANGE 0 TO 511
;
	LD	L,(IX+RECLEN)			; GET LENGTH OF CURRENT BUFFER
	LD	H,(IX+RECLEN+1)
	SCF					; COMPARE POINTER WITH LENGTH
	SBC	HL,DE
;
	JR	C,MRD2				; IF POINTER >= LENGTH THEN NEXT RECORD
;
	INC	DE				; ELSE INCREMENT POINTER
	LD	(IX+CHBYTE),E
	LD	(IX+CHBYTE+1),D
	DEC	DE
;
	PUSH	IX
	ADD	IX,DE				; GET BYTE AND SET CARRY
	LD	A,(IX+CHDATA)
	POP	IX
	SCF
	RET
;
MRD2
	BIT	1,(IX+RECFLG)			; WAS THIS THE LAST RECORD?
	JR	Z,MRD3
	XOR	A				; YES..CLEAR FLAGS AND RETURN
	ADD	A,0DH
	RET
;
MRD3
	LD	DE,0				; NEW BLOCK..NEW POINTERS
	LD	(IX+CHBYTE),E
	LD	(IX+CHBYTE+1),D
;
	INC	(IX+CHREC)			; NEW RECORD
;
	CALL	READN				; READ THIS RECORD
	XOR	A
	CALL	DRVSEL				; TURN OFF THE MOTOR AFTER USE
;
	JR	MRD1				; AND GET THE BYTE AS BEFORE
;
;
;*********************************************
;*    READN                                  *
;*********************************************
;
;
; THIS PROCEDURE READS A RECORD FROM THE CURRENTLY SELECTED DRIVE
; THIS RECORD IS IDENTIFIED BY THE CHANNEL DATA AT IX
; THE PROCEDURE MAKES TRYS PASSES AROUND THE TAPE BEFORE GIVING UP
; FAILURE TO FIND THE CORRECT BLOCK WILL RESULT IN AN ERROR.
;
READN
	LD	A,(IX+CHDRIV)			; SELECT THE DRIVE
	CALL	DRVSEL
;
READNC
	LD	BC,TRYS*HD_MAX
	LD	(SECTOR),BC			; *
RDN1
	CALL	RDNXT				; READ THE NEXT DATA BLOCK
	JR	C,RDN2				; NEXT SECTOR IF NO GOOD
	JR	Z,RDN2				; OR EMPTY
;
	LD	A,(IX+RECNUM)
	CP	(IX+CHREC)			; IS IT THE RIGHT NUMBER
	JR	NZ,RDN2
;
	PUSH	IX
	POP	HL
	LD	DE,CHDATA
	ADD	HL,DE
	CALL	ECD				; YES...ERROR CHECK AND RETURN
	RET	Z
RDN2
	CALL	DECSEC
	JR	NZ,RDN1
;
	RST	SH_ERR
	DEFB	011H				; FILE NOT FOUND
;
; RDNXT READS THE NEXT DATA BLOCK ON A DRIVE IT IS USED
; IN READN, READ_ AND OPENF
; RETURNS C IF THE RECORD WAS UNREADABLE OR WRONG NAME
;         Z IF THE RECORD WAS EMPTY
;     NC,NZ IF THE RECORD WAS READABLE AND RIGHT NAME
; NB IT DOES NOT ERROR CHECK THE DATA BLOCK
;
RDNXT
	CALL	WTHDR				; WAIT FOR A HEADER
;
	LD	DE,CHDES-CHHDR
	ADD	HL,DE
;
	CALL	RDBLK				; READ DATA BLOCK
	CALL	ECH				; CHECK THE DESCRIPTOR
	JR	NZ,RDNX1			; CARRY FLAG IF NO GOOD
;
	BIT	0,(IX+RECFLG)			; IS IT REALLY A DESCRIPTOR
	JR	NZ,RDNX1			; CARRY FLAG IF NOT
;
	LD	A,(IX+RECFLG)			; IS IT FULL OR EOF
	OR	(IX+RECLEN+1)
	AND	2
	RET	Z				; NC,Z IF EMPTY
;
	PUSH	IX				; HAS IT GOT THE SAME NAME
	POP	HL
	LD	DE,RECNAM
	ADD	HL,DE
	LD	BC,10
	CALL	CPSTR
	JR	NZ,RDNX1			; CARRY FLAG IF NOT
;
	LD	A,0FFH
	OR	A				; NC,NZ IF GOOD
	RET   
;
RDNX1
	SCF					; CARRY IF UNREADABLE OR WRONG
	RET
;
;
;
;**********************************************
;*   BYTE OUTPUT                              *
;**********************************************
;
; MWRCH WRITE THE BYTE IN A TO THE MICRODRIVE CHANNEL
; SPECIFIED BY DE
; (DE POINTS TO THE SECOND BYTE OF THE ADDRESS OF MWRCH IN
; THE CHANNEL DATA)
;
MWRCH
	LD	IX,-6
						; POINT IX AT THE CHANNEL
	ADD	IX,DE
MWRIX
	BIT	WRFLG,(IX+CHFLAG)		; IS IT OPEN FOR WRITE?
	JR	NZ,MWR1
;
	RST	SH_ERR				; NO...WRITING TO READ FILE
	DEFB	0CH
;
MWR1
	LD	E,(IX+CHBYTE)			; GET POINTER TO NEXT BYTE
	LD	D,(IX+CHBYTE+1)
;
	PUSH	IX				; WRITE BYTE
	ADD	IX,DE
	LD	(IX+CHDATA),A
	POP	IX
;
	INC	DE				; NEXT BYTE
	LD	(IX+CHBYTE),E
	LD	(IX+CHBYTE+1),D
;
	BIT	1,D				; BUFFER FULL?
	RET	Z				; STILL SPACE SO RETURN
;
;*********************************************
;*    WRITE RECORD                           *
;*********************************************
;
;
; THIS PROCEDURE WRITES THE DATA BLOCK DESCRIBED BY THE CHANNEL
; AT IX ONTO TAPE.
; THE CODE IS USED BY MWRCH AND CLOSEN
; WRREC CALLS THE SUBROUTINE WRC THIS DOES MOST OF THE WORK
; BUT LEAVES THE MOTOR RUNNING. THIS SUBROUTINE CAN BE USED
; INSTEAD OF WRREC BY SAVE IN ORDER TO SPEED-UP THIS
; INSTRUCTION
;
;
WRREC
	LD	A,(IX+CHDRIV)
	CALL	DRVSEL
	LD	BC,13000			; WAIT 100MS FOR GOOD CHANCE
	CALL	DELBC				; OF READING FIRST TIME
	CALL	WRC
	XOR	A
	CALL	DRVSEL
	RET
;
;
WRC
	CALL	SPACE?				; IS THERE ANY ROOM ON THE MAP
	JR	NZ,MWR4
	CALL	DELIX
	XOR	A
	CALL	DRVSEL
	RST     SH_ERR
	DEFB	0FH				; DELETE CHANNEL AND 'MICRODRIVE FULL'
;
MWR4
	PUSH	IX				; MOVE NAME INTO DESCRIPTOR
	LD	B,10
MWR2
	LD	A,(IX+CHNAME)
	LD	(IX+RECNAM),A
	INC	IX
	DJNZ	MWR2
	POP	IX
;
	LD	C,(IX+CHBYTE)			; MOVE LENGTH INTO DESCRIPTOR
	LD	(IX+RECLEN),C
	LD	A,(IX+CHBYTE+1)
	LD	(IX+RECLEN+1),A
;
	LD	A,(IX+CHREC)			; MOVE RECORD NUMBER INTO DESCRIPTOR
	LD	(IX+RECNUM),A
;
	PUSH	IX				; ERROR ENCODE DESCRIPTOR
	POP	HL
	LD	DE,CHDES+PLEN
	ADD	HL,DE
	CALL	ECH
;
	LD	DE,CHDATA-CHDES-PLEN		; THEN DATA
	ADD	HL,DE
	CALL	ECD
;
	PUSH	IX
	POP	HL
	LD	DE,RECNAM
;
;
MWR3
	CALL	WRFREE				; WRITE THE BLOCK TO THE NEXT FREE
;
	LD	DE,0				; SET BYTE POINTER TO START AGAIN
	LD	(IX+CHBYTE),E
	LD	(IX+CHBYTE+1),D
;
	INC	(IX+CHREC)
	RET
;
;
; SPACE? CHECKS THE MAP TO SEE IF THERE IS A FREE BLOCK
; IT RETURNS THE ZERO FLAG IF THERE IS NO SPACE
;
SPACE?
	LD	L,(IX+CHMAP)
	LD	H,(IX+CHMAP+1)
	LD	B,MAPLN				; TEST THE MAP TO SEE IF THERE IS ROOM
SP1
	LD	A,(HL)
	CP	0FFH
	RET	NZ
	INC	HL
	DJNZ	SP1
	XOR	A
	RET
;
;
; WRFREE WRITES THE DATA BLOCK FOR THE CHANNEL POINTED TO BY IX
; ONTO THE NEXT FREE SECTOR ON THE DISK
;
WRFREE
	PUSH	IX				; GET POINTER TO DATA BLOCK
	POP	HL
	LD	DE,CHDES
	ADD	HL,DE
	PUSH	HL
;
WRFR0
	CALL	WTHDR				; WAIT FOR A HEADER
;
	CALL	FREE?				; IS IT MARKED FREE?
	JR	NZ,WRFR0			; NO...NEXT HEADER
;
	EX	(SP),HL				; * SAVE POINTER FOR LATER
	PUSH	BC

	IN	A,(PORTC)
	AND	PROTECT				; IS THE DRIVE WRITE PROTECTED?
	JR	NZ,WR11
	RST	SH_ERR
	DEFB	0EH				; DRIVE WRITE PROTECTED
WR11
	LD	A,ERASE.AND.CTS.AND.SELD
	OUT	(PORTC),A			; ERASE ON TO TIDY UP LONG BLOCKS
	LD	BC,GAPT3			; LEAVE ON FOR 2.3MS BEFORE WRITING
	CALL	DELBC
;
	CALL	WRBLK				; WRITE THE DATA
;
	LD	A,CTS.AND.SELD
	OUT	(PORTC),A			; NOT FORGETTING TO TURN OFF THE ERASE
;
	POP	BC				; NOW UPDATE THE MAP
	POP	HL
	LD	A,B
	OR	(HL)
	LD	(HL),A
;
	RET
;
;**********************************************
;*    CLOSE                                   *
;**********************************************
;
; CLOSEN CLOSES THE MICRODRIVE CHANNEL SPECIFIED BY HL
;
CLOSEN
	PUSH	HL
	POP	IX
CLOSIX
	BIT	WRFLG,(IX+CHFLAG)		; IS IT READ OR WRITE?
	JR      Z,CLOSE1			; READ...DELETE CHANNEL
;
	SET	1,(IX+RECFLG)			; WRITE...MARK DATA EOF
;
	CALL	WRREC				; AND WRITE ONTO DISK
;
CLOSE1
	XOR	A
	CALL	DRVSEL
;
	CALL	DELIX				; DELETE CHANNEL
;
	RET
;
NERROR
	POP	HL
	LD	A,(HL)
	LD	(ERR_NR),A
	RST	ROMERR
;
;
;********************************************
;*  UTILITIES                               *
;********************************************
;
; WTHDR WAITS FOR THE FIRST ERROR FREE HEADER BLOCK AND
; READS IT INTO THE HEADER BUFFER IDENTIFIED BY IX
;
WTHDR
	PUSH	IX
	POP	HL				; POINT TO HEADER BLOCK
	LD	DE,CHHDR+PLEN
	ADD	HL,DE
;
	CALL	RDHBLK				; READ A HEADER BLOCK
	CALL	ECH
	JR	NZ,WTHDR			; REPEAT IF NO GOOD
;
	BIT	0,(IX+HDFLAG)			; IS IT A HEADER BLOCK
	JR	Z,WTHDR
;
	RET
;
;
;
; FREE? LOOKS AT THE HEADER BLOCK POINTED TO BY IX EXTRACTS THE
; SECTOR NUMBER AND CHECKS THE MAP TO SEE IF THE FOLLOWING
; DATA BLOCK IS FREE.
; THE ZERO FLAG IS SET IF THE BLOCK IS FREE
; HL IS LEFT POINTING AT THE RELEVANT BYTE IN THE MAP
; B IS LEFT CONTAINING THE RELEVANT BIT
; DONE? DOES THE SAME AS FREE? BUT USES THE RECORD NUMBER
; INSTEAD OF THE SECTOR NUMBER
;
DONE?
	LD	E,(IX+RECNUM)
	JR	FREE0
FREE?
	LD	E,(IX+HDNUMB)			; GET SECTOR NUMBER
FREE0
	LD	L,(IX+CHMAP)
	LD	H,(IX+CHMAP+1)
FREE1
	XOR	A
	LD	D,A
	LD	A,E				; DIVIDE BY 8 REMAINDER IN A
	AND	7
	SRL	E
	SRL	E
	SRL	E
	ADD	HL,DE				; DEAL WITH BYTE
;
	LD	B,A
	INC	B
	XOR	A
	SCF
FREE3
	RLA					; SORT OUT BIT
	DJNZ	FREE3
;
	LD	B,A
;
	AND	(HL)				; IS IT FREE?
	RET
;
; MARK MARKS THE CURRENT SECTOR FREE IN THE MAP
;
MARK
	CALL	FREE?
	LD	A,B
	CPL
	AND	(HL)
	LD	(HL),A
	RET
;
; LIST? DOES THE SAME AS FREE? EXCEPT THAT IT WORKS ON THE LIST
; OF BLOCKS IN THE CHANNEL DATA.
;
LIST?
	PUSH	IX
	POP	HL
	LD	DE,CHDATA
	ADD	HL,DE
	LD	E,(IX+HDNUMB)
	JR	FREE1
;
;
; DECSEC DECREMENTS AND TESTS (SECTOR) IT IS USED BY MANY
; OF THE PROCEDURES WHICH HAVE TO LOOK AT ALL THE SECTORS
; ON A DRIVE.
;
DECSEC
	LD	BC,(SECTOR)
	DEC	BC
	LD	(SECTOR),BC
	LD	A,B
	OR	C
	RET
;
;
; CPSTR COMPARES THE FILENAME AT (IX+CHNAME) WITH
; THE BC BYTES AT (HL). THE ZERO FLAG IS SET IF THERE IS
; A MATCH.
; IF THERE ARE FEWER THAN 10 BYTES AT HL THE REST OF THE NAME
; AT IX+CHNAME MUST BE SPACES
;
CPSTR
	PUSH	IX
	LD	B,10
CPS9
	LD	A,(HL)
	CP	(IX+CHNAME)
	JR	NZ,CPS8
	INC	HL
	INC	IX
	DEC	B
	DEC	C
	JR	NZ,CPS9
	LD	A,B
	OR	A				; 10 BYTES?
	JR	Z,CPS8
CPS7
	LD	A,(IX+CHNAME)			; NO...MAKE SURE THE REST ARE SPACES
	CP	' '
	JR	NZ,CPS8
	INC	IX
	DJNZ	CPS7
CPS8
	POP	IX
	RET
;
; ECH AND ECD COMPARE AND COMPUTE THE CHECKSUMS FOR HEADER
; AND DATA BLOCKS RESPECTIVELY
; THE CHECKSUM IS COMPUTED SUM MOD 255 IT IS COMPARED
; WITH THE BYTE AT THE END OF THE BLOCK AND THE NEW CHECKSUM
; IS STORED THERE.
; THE SAME PROCEDURE CAN THEREFORE BE USED FOR COMPUTING
; AND CHECKING THE CHECKSUM;
; THE ZERO FLAG IS SET IF THE CHECKSUM IS GOOD
;
ECH
	LD	BC,HD_LEN-PLEN-1
	JR	ECD1
ECD
	LD	BC,D_LEN-HD_LEN-1
ECD1
	PUSH	HL
	LD	E,0
ECD2
	LD	A,E
	ADD	A,(HL)
	INC	HL
	ADC	A,1
	JR	Z,ECD3
	DEC	A
ECD3
	LD	E,A
	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,ECD2
;
	LD	A,E
	CP	(HL)
	LD	(HL),A
	POP	HL
	RET
;
;
; ADJSTR ADJUSTS THE POINTERS INN THE STREAM DATA WHEN A
; CHANNEL IS DELETED
; THE OFFSET OF THE CHANNEL IS STORED IN HL THE
; LENGTH OF THE CHANNEL IS STORED IN BC
; THE STREAM OPENED TO THE CLOSED CHANNEL IS RESET
;
ADJSTR
	PUSH	HL
	LD	A,16
	LD	HL,STRMS+6
ADJ1
	LD	(X_PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	POP	HL
	PUSH	HL
	OR	A
	SBC	HL,DE				; COMPARE CHANNEL - POINTER
	JR	NZ,ADJ3
	LD	DE,0				; RESET STREAM IF EQUAL
	JR	ADJ4
ADJ3
	JR	NC,ADJ2				; IF POINTER EXCEEDS CHANNEL
	EX	DE,HL				; * THEN REDUCE OFFSET
	OR	A
	SBC	HL,BC
	EX	DE,HL				; *
ADJ4
	LD	HL,(X_PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
ADJ2
	LD	HL,(X_PTR)
	INC	HL
	INC	HL
	DEC	A
	JR	NZ,ADJ1				; NEXT STREAM
	LD	(X_PTR),A
	POP	HL
	RET
;
; ADJMAP ADJUSTS THE POINTERS TO MAPS IN MICRODRIVE CHANNELS
; AFTER A MAP IS DELETED
; HL CONTAINS THE ADDRESS OF THE DELETED MAP
;
ADJMAP
	LD	BC,MAPLN
	LD	IX,(CHANS)
	LD	DE,20
	ADD	IX,DE				; START AT IMPERMANENT CHANNELS
ADJM1
	LD	A,(IX+0)			; IS THERE A CHANNEL?
	CP	80H
	RET	Z				; RETURN IF ALL DONE
;
	PUSH	HL
	LD	A,(IX+CHTYPE)
	AND	7FH
	CP	'M'				; IS IT A MICRODRIVE CHANNEL
	JR	NZ,ADJM2
;
	LD	E,(IX+CHMAP)			; YES...LOOK AT MAP ADDRESS
	LD	D,(IX+CHMAP+1)
	SBC	HL,DE
	JR	NC,ADJM2			; NEXT IF LESS THAN DELETED MAP
;
	EX	DE,HL				; *
	OR	A
	SBC	HL,BC				; ADJUST IF ABOVE
	LD	(IX+CHMAP),L
	LD	(IX+CHMAP+1),H
ADJM2
	POP	HL				; NEXT CHANNEL
	LD	E,(IX+CHLEN)
	LD	D,(IX+CHLEN+1)
	ADD	IX,DE
	JR	ADJM1
;
;
;********************CHANNEL***************
;
;
; THE FOLLOWING DATA IS USED AS INITIALIZATION DATA FOR MICRO
; DRIVE CHANNEL INFORMATION
;
MCHDAT	DEFW	8				; ERROR ADDRESS AS USED BY OLD WRCH
	DEFW	8				; ERROR ADDRESS AS USED BY OLD RDCH
	DEFB	'M'+80H				; CHANNEL TYPE...DEFAULT TEMPORARY
	DEFW	MWRCH				; ADDRESS USED BY NEW WRCH
	DEFW	MRDCH				; ADDRESS USED BY NEW RDCH
	DEFW	CHANLN				; LENGTH OF THIS CHANNEL DATA
	DEFW	0				; CURRENT BYTE POINTER
	DEFB	0				; CURRENT RECORD
	DEFW	2020H				; INITIAL NAME ALL SPACES
	DEFW	2020H
	DEFW	2020H
	DEFW	2020H
	DEFW	2020H
	DEFB	0FFH				; INITIALLY OPENED FOR WRITE
;
;
; THE FOLLOWING DATA IS USED TO INITIALIZE THE PREAMBLE DATA
;
P_AMBL
	DEFW	0
	DEFW	0
	DEFW	0
	DEFW	0
	DEFW	0
	DEFW	0FFFFH
