;
;********************************************************************
;
;		HOOK CODE MODULE	- SH_HOOK.S
;
;********************************************************************

;	GLOBAL HOOKS

;	EXTERNAL RETBAS
;	EXTERNAL ACT_FT,ACT_OT,IN_BYP,OUT_T,OUT_T2,IN_BYT
;	EXTERNAL OUT_N,OUTNET,GETPAK,ACT_ON,NOPEN,INPAK,RSPOND,OUTPAK
;	EXTERNAL   NTEMP,ONET0,NTCLSE,INSCT,BCOL
;	EXTERNAL	DRVSEL,OPENF,CLOSIX,READN,DELIX,WRREC
;	EXTERNAL	ERA
;	EXTERNAL	WTHDR,DECSEC,ECH,ECD,RDBLK,DELBC,WRBLK,FREE?

;______________________________________________________________

HOOKS		; DEAL WITH THE HOOK CODES
		; HL POINTS TO THE 'DEFB'
		; THE ORIGINAL AF IS ON THE STACK
		; 'A' HOLDS THE HOOK CODE

	CP	H_LEN/2				; NUMBER OF HOOK ADDRESSES IN THE TABLE
	JR	C,HOOK1

	RST	SH_ERR
	DEFB	12H				; 'HOOK CODE ERROR'

HOOK1	LD	(IY+ERR_NR-Y),0FFH		; SIGNAL NO ERROR AFTER ALL
	SET	2,(IY+FLAGS-Y)			; IN CASE THERE IS AN ERROR
						; SO WE KNOW WHO TO RETURN-TO
	INC	HL				; FORM THE RETURN ADDRESS
	EX	(SP),HL
	PUSH	HL				; PUT IT ON THE STACK ABOVE THE 'AF'
	ADD	A,A				; DOUBLE THE HOOK CODE
	LD	D,00H
	LD	E,A				; 'DE' NOW HOLDS TABLE OFFSET
	LD	HL,H_BASE			; HOOK TABLE BASE ADDRESS
	ADD	HL,DE				; INDEX INTO TABLE
	LD	E,(HL)				; FETCH LOW BYTE
	INC	HL
	LD	D,(HL)				; FETCH HIGH BYTE
	POP	AF				; FETCH ORIGINAL 'AF'
	LD	HL,RETBAS			; THE RETURN ADDRESS IS VIA RETBAS AS USUAL
	PUSH	HL
	EX	DE,HL				; JUMP ADDRESS TO HL
	JP	(HL)				; NOW JUMP TO IT
						; RETURNING TO RETBAS AND HENCE TO CONTINUATION ADDRESS
;______________________________________________________________________
H_CALL	LD	HL,(DR+ROMADD)			; FETCH THE 'PASSED' ADDRESS
	JP (HL)
;________________________________________________________________
H_RET	RET					; WILL EFFECT THE INSERTION OF THE SHADOW S. V.

;________________________________________________________________

H_BASE
	DEFW	CONIN				; CODE 27 CONSOLE INPUT
	DEFW	CONOUT				; CODE 28 CONSOLE OUTPUT
	DEFW	IN_BYP				; CODE 29 RS232 INPUT
	DEFW	OUT_T2				; CODE 30 RS232 OUTPUT
	DEFW	ZXOUT				; CODE 31 ZX PRINTER OUTPUT
	DEFW	DIRECT				; CODE 32 TEST KEYBOARD
	DEFW	DRVSEL				; CODE 33 DRIVE SELECT
	DEFW	OPENF				; CODE 34 OPEN A FILE
	DEFW	CLOSIX				; CODE 35 CLOSE A FILE
	DEFW	ERA				; CODE 36 DELETE A FILE
	DEFW	READSQ				; CODE 37 READ SEQUENTIAL
	DEFW	WRREC				; CODE 38 WRITE RECORD
	DEFW	READRN				; CODE 39 READ RANDOM
	DEFW	READSC				; CODE 40 READ SECTOR
	DEFW	READNX				; CODE 41 READ NEXT SECTOR
	DEFW	WRSC				; CODE 42 WRITE SECTOR
	DEFW	OPENF				; CODE 43 CREATE MICRODRIVE BUFFER ***
	DEFW	DELIX				; CODE 44 DELETE MICRODRIVE BUFFER
	DEFW	NTEMP				; CODE 45 OPEN A NETWORK CHANNEL
	DEFW	N_CLOS				; CODE 46 CLOSE A NETWORK CHANNEL
	DEFW	GE_PAK				; CODE 47 GET NETWORK PACKET
	DEFW	ONET0				; CODE 48 SEND A NETWORK PACKET
	DEFW	H_RET				; CODE 49 CREATE SYSTEM VARIABLES
	DEFW	H_CALL				; CALL A DESIGNATED SUBROUTINE
H_LEN	EQU	$-H_BASE

;__________________________________________________________________
CONIN						; KEYBOARD INPUT ROUTINE
	EI
	RES	5,(IY+FLAGS-Y)
_IN1						; *
	HALT
	OLDCAL	02BFH				; KEYBOARD SCAN
	BIT	5,(IY+FLAGS-Y)
	JR	Z,_IN1				; *

	LD	A,(LAST_K)
	RET

CONOUT
	PUSH	AF
	LD	A,0FEH				; PERMANENT STREAM
_OUT1						; *
	LD	HL,SCRCT			; RESET SCROLL COUNT
	LD	(HL),0FFH
	OLDCAL	SELECT
	POP	AF
	OLDCAL	10H
	RET

ZXOUT
	PUSH	AF
	LD	A,3
	JR	_OUT1				; *

DIRECT
	XOR	A
	IN	A,(0FEH)
	AND	1FH
	SUB	1FH				; CARRY SET IF <> 1FH
	RET

READSQ
	BIT	1,(IX+RECFLG)			; EOF?
	JR	Z,_RD1

	LD	(IY+ERR_NR-Y),7			; ERROR RETURN
	RST	ROMERR
_RD1						; *
	INC	(IX+CHREC)			; NEXT RECORD
READRN
	CALL	READN				; READ RANDOM
_RD3						; *
	BIT	2,(IX+RECFLG)			; SLVM FILE?
	RET	Z				; NO...OK

	CALL	DELIX				; YES...REMOVE EVIDENCE

	RST	SH_ERR				; WRONG FILE TYPE
	DEFB	16H

N_CLOS
	CALL	NTCLSE				; SEND ANY REMAINING DATA
	PUSH	IX
	POP	HL
	LD	BC,N_LEN
	RST	CALBAS
	DEFW	DELREC				; AND DELETE THE BUFFER
	RET

GE_PAK
	LD	A,(DR+IOBORD)
	OUT	(0FEH),A			; SET THE BORDER COLOUR
	DI
	CALL	INSCT
	JR	NC,GE_ERR			; EXIT ON TIMEOUT
	CALL	GETPAK
	JR	NZ,GE_ERR			; OR ANY OTHER PROBLEM
	EI
	AND	A
	JP	B_COL
GE_ERR
	SCF
	EI
	JP	B_COL


READSC
	LD	HL,HD_MAX
	LD	(SECTOR),HL
RDSC1
	CALL	WTHDR				; GET A SECTOR HEADER
	LD	A,(IX+HDNUMB)
	CP	(IX+CHREC)			; IS IT THE RIGHT ONE

	JR	Z,RDSC2

	CALL	DECSEC
	JR	NZ,RDSC1
	RST	SH_ERR				; FILE NOT FOUND
	DEFB	11H

RDSC2
	PUSH	IX
	POP	HL
	LD	DE,CHDES+PLEN
	ADD	HL,DE

	CALL	RDBLK				; READ THE BLOCK
	CALL	ECH
	JR	NZ,RDSC3			; CHECK THE DESCRIPTOR

	LD	DE,CHDATA-CHDES-PLEN
	ADD	HL,DE
	CALL	ECD				; AND THEN THE DATA
	JR	NZ,RDSC3

	OR	A				; CLEAR THE CARRY FLAG
	BIT	2,(IX+RECFLG)			; IS IT SLVM
	RET	Z				; NO JUST RETURN

RDSC3
	CALL	VOID				; HERE IF BUFFER ERRONEOUS OR SLVM
	SCF
	RET

READNX
	LD	HL,HD_MAX
	LD	(SECTOR),HL
_RDNX1						; *
	CALL	WTHDR				; WAIT FOR A HEADER
	JR	RDSC2				; USE THE FIRST FOUND

WRSC	LD	HL,HD_MAX
	LD	(SECTOR),HL
	PUSH	IX
	POP	HL
	LD	DE,CHDES
	ADD	HL,DE
	PUSH	HL
	LD	DE,PLEN
	ADD	HL,DE
	CALL	ECH				; ERROR ENCODE THE DESCRIPTOR
	LD	DE,CHDATA-CHDES-PLEN
	ADD	HL,DE
	CALL	ECD				; AND THE DATA
WRSC1
	CALL	WTHDR				; WAIT FOR A HEADER
	LD	A,(IX+HDNUMB)
	CP	(IX+CHREC)			; IS IT THE RIGHT ONE
	JR	Z,WRSC2

	CALL	DECSEC
	JR	NZ,WRSC1

	RST	SH_ERR				; FILE NOT FOUND
	DEFB	11H
WRSC2
	IN	A,(PORTC)			; IS THE DRIVE WRITE PROTECTED
	AND	PROTECT
	JR	NZ,WRSC3

	RST	SH_ERR				; DRIVE WRITE PROTECTED
	DEFB	0EH

WRSC3
	LD	A,ERASE.AND.CTS.AND.SELD	; ERASE ON
	OUT	(PORTC),A
	LD	BC,GAPT3
	CALL	DELBC

	POP	HL				; WRITE DATA
	CALL	WRBLK

	LD	A,CTS.AND.SELD
	OUT	(PORTC),A			; ERASE OFF

	CALL	FREE?				; FIND POSITION ON THE MAP

	LD	A,B
	OR	(HL)
	LD	(HL),A
	RET					; MARK MAP AND RETURN

VOID
	PUSH	IX				; COPIES THE FIRST BYTE OF A BUFFER
	POP	HL				; INTO THE REST
	LD	DE,CHDATA
	ADD	HL,DE
	LD	D,H
	LD	E,L
	INC	DE
	LD	BC,511
	LDIR
	RET

;??????UNFINISHED
